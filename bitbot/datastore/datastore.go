package datastore

// generate the in-memory scripts filesystem
//go:generate statik -f -src ./scripts

import (
	"database/sql"
	"fmt"
	"github.com/pkg/errors"
	_ "github.com/resc/rescbits/bitbot/datastore/statik"
	"time"
)

const (
	queryInsertPriceSample      = "INSERT INTO public.pricesamples (timestamp,type,price) VALUES ($1, $2, $3)"
	querySelectPriceSample      = "SELECT timestamp,type,price FROM public.pricesamples WHERE timestamp BETWEEN $1 AND $2 ORDER BY timestamp LIMIT $3"
	querySelectPriceSampleCount = "SELECT count(timestamp) FROM public.pricesamples WHERE  $1 <= timestamp AND timestamp < $2"
	queryDeletePriceSamples     = "DELETE FROM public.pricesamples WHERE  $1 <= timestamp AND timestamp < $2"
)

/* INSERT
var userid int
err := db.QueryRow(`INSERT INTO users(name, favorite_fruit, age)
	VALUES('beatrice', 'starfruit', 93) RETURNING id`).Scan(&userid)

*/
type (
	// DataStore
	DataStore interface {
		// Ping verifies the connection to the datastore
		Ping() error

		// Start opens a connection to the data source and starts a new unit of work
		StartUow() (UnitOfWork, error)

		// Closes the datastore
		Close() error
	}

	// UnitWork
	UnitOfWork interface {
		// SavePriceSamples save te given price samples
		SavePriceSamples(samples ...PriceSample) error

		// LoadPriceSamples loads the the numberof price samples from the given datae
		LoadPriceSamples(from time.Time, to time.Time, maxResults int) (results []PriceSample, totalResults int, err error)

		// DeletePriceSamples deletes the samples between from and to.
		// It returns the number of deleted entries, or an error
		DeletePriceSamples(from time.Time, to time.Time) (int, error)

		// LoadAlerts loads all alerts for the users or all alerts if no userID is supplied
		LoadAlerts(userID ...string) ([]PriceAlertTrigger, error)

		// DeleteAlerts deletes all alerts for which an id is supplied
		DeleteAlerts(id ...int64) (int, error)

		// SaveAlert saves a new alert
		SaveAlert(alert PriceAlertTrigger) (PriceAlertTrigger, error)

		// Commits the transaction
		Commit() error

		// Rollback rolls back al changes
		Rollback() error
	}

	// PriceAlertTrigger
	PriceAlertTrigger struct {
		// Id the alert id, generated by the data store, should be zero when calling UnitOfWork.SaveAlert
		Id int64

		// The user that set the price alert.
		UserID string

		// The channel used to set the price alert.
		ChannelID string

		// Type can be buy or sell.
		// For buy the alert triggers when the market price dips below Price,
		// and re-arms when the market price goes above Price + ResetHysteresis
		// for sell the alert triggers when the market price goes above Price
		// and rearms when the market price goes below Price - ResetHysteresis
		Type SampleType

		// Price in  EUR * 1e5 / BTC
		Price int64

		// IsArmed is true when the trigger can go off, false when the trigger hes been triggered and not re-armed
		IsArmed bool

		// ResetHysteresis is the amount in EUR * 1e5 / BTC below Price where the trigger is automatically re-armed
		ResetHysteresis int64

		// LastTriggerTimestamp is the last time when the alert was triggered
		LastTriggerTimestamp time.Time

		// TriggerCount  is the number of times the alert was triggered
		TriggerCount int32
	}

	SampleType string
)

const (
	SampleTypeNone SampleType = ""
	SampleTypeBuy  SampleType = "B"
	SampleTypeSell SampleType = "S"
)

func (x SampleType) String() string {
	return string(x)
}

func ParseSampleType(s string) SampleType {
	switch s {
	case "b":
		fallthrough
	case "B":
		return SampleTypeBuy
	case "s":
		fallthrough
	case "S":
		return SampleTypeSell
	default:
		return SampleTypeNone
	}
}

type (
	// PriceSample
	PriceSample struct {
		// Time of  sample measurement
		Timestamp time.Time
		// Type  B/S for Buy/Sell
		Type SampleType
		// SellPrice in 1/1e5 EUR / BTC
		Price int64
	}
)

func (s *PriceSample) Scan(r *sql.Rows) error {
	return r.Scan(&s.Timestamp, &s.Type, &s.Price)
}
func (s *PriceSample) String() string {
	return fmt.Sprint("PriceSample", s.Timestamp, s.Type, s.Price)
}

type (
	datastore struct {
		db *sql.DB
	}
)

var _ DataStore = (*datastore)(nil)

func Open(connectionString string) (DataStore, error) {
	if db, err := sql.Open("postgres", connectionString); err != nil {
		return nil, err
	} else {
		return &datastore{
			db: db,
		}, nil
	}
}

func (ds *datastore) StartUow() (UnitOfWork, error) {
	if tx, err := ds.db.Begin(); err != nil {
		return nil, err
	} else {
		return &uow{
			tx: tx,
		}, nil
	}
}

func (ds *datastore) Ping() error {
	return ds.db.Ping()
}

func (ds *datastore) Close() error {
	return ds.db.Close()
}

type (
	uow struct {
		tx *sql.Tx
	}
)

var _ UnitOfWork = (*uow)(nil)

func (u *uow) SavePriceSamples(samples ...PriceSample) error {
	if stmt, err := u.tx.Prepare(queryInsertPriceSample); err != nil {
		return err
	} else {
		defer stmt.Close()
		for i := range samples {
			if res, err := stmt.Exec(samples[i].Timestamp.UTC(), samples[i].Type.String(), samples[i].Price); err != nil {
				return err
			} else {
				if rowsAffected, err := res.RowsAffected(); err != nil {
					return err
				} else if rowsAffected < 1 {
					return errors.Errorf("Expected one or more rows affected")
				}
			}
		}
		return nil
	}
}

func (u *uow) LoadPriceSamples(from time.Time, to time.Time, maxResults int) ([]PriceSample, int, error) {
	totalResults := int64(0)

	rows, err := u.tx.Query(querySelectPriceSampleCount, from.UTC(), to.UTC())
	if err != nil {
		return nil, 0, err
	}

	defer rows.Close()

	for rows.Next() {
		err = rows.Err()
		if err != nil {
			return nil, 0, err
		}

		if err := rows.Scan(&totalResults); err != nil {
			return nil, 0, err
		}
		err = rows.Err()
		if err != nil {
			return nil, 0, err
		}
	}

	if totalResults == 0 {
		return nil, 0, nil
	}

	if int(totalResults) < maxResults {
		maxResults = int(totalResults)
	}

	if rows, err := u.tx.Query(querySelectPriceSample, from.UTC(), to.UTC(), maxResults); err != nil {
		return nil, 0, err
	} else {
		results := make([]PriceSample, 0, maxResults)
		for rows.Next() {
			row := PriceSample{}
			st := ""
			if err := rows.Scan(&row.Timestamp, &st, &row.Price); err != nil {
				return nil, 0, err
			} else {
				row.Type = ParseSampleType(st)
				results = append(results, row)
			}
		}
		return results, int(totalResults), nil
	}
}

func (u *uow) DeletePriceSamples(from time.Time, to time.Time) (int, error) {
	if stmt, err := u.tx.Prepare(queryDeletePriceSamples); err != nil {
		return 0, err
	} else {
		defer stmt.Close()
		if res, err := stmt.Exec(from.UTC(), to.UTC()); err != nil {
			return 0, err
		} else {
			if rowsAffected, err := res.RowsAffected(); err != nil {
				return 0, err
			} else {
				return int(rowsAffected), nil
			}
		}
	}
	return 0, nil
}

func (*uow) LoadAlerts(userID ...string) ([]PriceAlertTrigger, error) {
	panic("implement me")
}

func (*uow) DeleteAlerts(id ...int64) (int, error) {
	panic("implement me")
}

func (*uow) SaveAlert(alert PriceAlertTrigger) (PriceAlertTrigger, error) {
	panic("implement me")
}

func (u *uow) Commit() error {
	return u.tx.Commit()
}

func (u *uow) Rollback() error {
	return u.tx.Rollback()
}
